\documentclass[format=acmsmall, review=false, screen=true]{acmart}
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column
\pagestyle{plain} % removes running headers
\acmYear{2018}
\acmMonth{7}

\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{dirtytalk}


\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  aboveskip=10pt,
  belowskip=5pt,
  tabsize=2
} 

\setlength{\textfloatsep}{15pt}
\setlength{\abovecaptionskip}{6pt}
\setlength{\belowcaptionskip}{6pt}

\author{Richard Bányi}

\title{\textsc{Comparing Braintenberg vehicles evolved using classical evolutionary algorithms and neuroevolution}}
\subtitle{\textsc{IT University of Copenhagen, Spring 2018}}
\acmDOI{}
\begin{document}
\begin{abstract}
The purpose of this project is to compare different evolution strategies to the evolution and optimization of Braitenberg vehicle using classical evolutionary algorithms and neuroevolution. Braitenberg vehicles are special class of agents that can autonomously move around based on its sensor inputs. Braitenberg vehicles are controlled by number of parameters, depending how the sensors and wheels are connected we can exhibit different behaviors. We show how basic evolutionary algorithms (EA’s) and neuroevolution can emulate a Braitenberg vehicle in a way that it avoids obstacles. Although the experiments will consists of a simple task of navigation and obstacle avoidance, our major goal of the project on autonomous agents is to emphasize the main differences  of both approaches. V-Rep simulator will be used to test and track the evolution, however we intend to test on a real physical agent.
	\end{abstract}
\maketitle


\section{Introduction}

Autonomous agents are characterized as intelligent agents that pursue certain goal without external supervision or control. Take for example a self-driving car\cite{eberhard200621}, its goal is to drive from point A to point B, while ensuring the safety of its passengers, as well it has to be able to maintain its internal energy level and when its batteries are on low it drives to the nearest charging stations. In real world situation the self-driving har has to be able to adapt to different environments, driving on the highway or on the country side requires different behavioral capabilities. All of these features of autonomous agents are way to complex to pre-define, and should rather emerge from the interaction between the robot and its own environment. Building an abstract pre-defined models of the world is not sufficient in an continuously changing environment. Returning back to the example of self-driving car, putting a whole map of the environment into the vehicle is not sufficient, since the environment is constantly changing, a car might encounter a unexpecting crossing pedestrian or road block which was not part of the abstract model. Autonomous agents are quipped with sensors and actuators. An agent perceives its environment trough sensors like proximity, infrared sensors and it interacts with its environment by using actuators. 

Major steps have been already taken for building autonomous systems using classical AI approach. On one hand there is the approach termed \emph{behavior-based-robotics} from the 1980's\cite{arkin1998behavior}. Behavior based robotics emphasize the importance of continuous interaction between the robot and its own environment for the dynamic development of the control system \cite{siciliano2016springer}. As contrasted to classical \emph{Knowledge-Based Artificial Intelligence} which is more concerned with a high level of definition of the environment. For example, the agent first sense the environment, then usually a model is built, and the robot has to reason upon this model to decide which action to take. Wahde\cite{wahde2004evolutionary} contend that this approach is very slow and could not be executed in real world.


Beside these solutions, some other researchers have developed autonomous systems by employing various sorts of neural networks to control a robot. A  different approach is taken by researchers that try to evolve the robot control system using evolutionary algorithms. Rather than design a solution, they describe the robot characteristics in form of an chromosome. \emph{Evolutionary algorithms} \cite{back1996evolutionary} focus on global optimization problems inspired by biological evolution. EA are population based, meta heuristic search procedures that incorporate genetic operators \cite{back1996evolutionary}. Algorithm maintains a population of candidate solutions which is subjected to natural selection and mutation. In each generation, a set of offspring is generated by applying bio operators such as \emph{mutation, crossover, selection}. Each generation, the fitness of every individual in the population is evaluated. More fit individuals are stochastically selected from the current population, and each individual's \emph{genome} is modified (recombined or randomly mutated) to form a new generation. The algorithm terminates when either the maximum number of generations has been produced, or fitness level has been reached for the population.

Within this approach, a number of researches have successfully employed and evolutionary procedure to develop a robot control system \cite{salomon1999evolving}. Although the evolutionary procedure is well know, it is not a straightforward task to apply, as discovered during implementation.

In this paper we describe the evolution of Braitenberg like obstacle avoidance vehicle using classical evolutionary algorithm and neuroevolution. In all our experiments the evolutionary procedure is carried out in a robot simulator called V-Rep \cite{rohmer2013v}.

\section{The Robot}

In the experiments reported in this paper, the simulator (robot) was controlled through external client. The remote API functions are interacting with V-REP (robot) via socket communication. A detailed description of V-REP and the remote API \footnote{\url{http://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm}} can be found online.

Pioneer P3DX was chosen for the purpose of the experiments. The robot is equipped with 16 proximity sensors and two motors. The motors can be controlled independently of each other by sending function calls to the simulator. The specifications of sensor readings and possible speed values, included normalization values are depicted in the table below \ref{fig:specs}.

\begin{table}[H]
\begin{tabular}{llll}
\hline
\textbf{}                            & \textbf{Simulator}   & \textbf{Normalized} & \textbf{Type} \\ \hline
\textbf{Speed Values}                & {[}0.0, 4.0{]}       & {[}0.0, 1.0{]}      & Float         \\
\textbf{Sensory Readings}            & {[}0.0, 1.0{]}       & {[}0.0, 1.0{]}      & Float         \\
\textbf{Detectable Object Distances} & {[}0.05, 1{]}        & {[}0.0, 1.0{]}      & Float         \\
\textbf{}                            & \textbf{No readings} & \textbf{Close}      & \textbf{Far}  \\
\textbf{Sensory Readings}            & 0.0                  & 0.1                 & 0.9          
\end{tabular}
\caption{Sensors and speed values specification}
\label{fig:specs}
\end{table}

\begin{figure}[H]
  \includegraphics[width=0.66\linewidth]{img/pioneer.PNG}
  \caption{The Pioneer P3DX robot}
  \label{fig:pioneer-robot}
\end{figure}

\section{Braitenberg Vehicles}

A Braitenberg vehicle \cite{braitenberg1986vehicles} is an agent that can autonomously move around and exhibit various different behaviors depending on its senor inputs. The vehicle is equipped with primitive sensors that measure certain quality, and 2 motors which functions as actuators. Depending on how the sensors and motors are connected, the vehicle exhibits different behaviors. Thus the motion of the vehicle is directly controlled by the sensors. Yet the resulting bahavior may appear complex or even intelligent.

Our control architecture was inspired by a Braitenberg type-2c vehicle - each sensor is connected to both motors. The sensor readings controls the motors via inhibitory and excitatory connections. The key idea is that a sensor with high proximity activation accelerate the motor on the proximity sensor's side while slows down the motor on the opposite side. The presence of an obstacle leads to different motor speeds, which causes the robot to turn or spin. The activation of motor's is calculated by the following formula:

\[ M_{lr} = \sum_{i=1}^{16} P_{i} w_{l_i r_i} \]

where \(P_{i}\) is the activation value of the proximity sensor \emph{i} and \(w_{lr_i}\) denotes the genome that connects proximity \(P_{i}\) with motors. In the absence of obstacle the calculation of the motor's activation is similar, however in this case the activation value of the proximity sensor's is left out:

\[ M_{lr} = \sum_{i=1}^{16} w_{l_i r_i} \]

\section{Experimental Setup}

\begin{figure}[H]
  \includegraphics[width=0.66\linewidth]{img/scene.PNG}
  \caption{The environment. The robot indicated position is the starting poing of every simulation as well for the fitness evaluation.}
  \label{fig:arena-scene}
\end{figure}

The robot is operating in an environment in a sort of squared corridor whose size is approximately 2x2m large in the simulator. Figure\ref{fig:arena-scene} shows the arena in which the robot has to move. In all experiments, the robot was started from an initial positions which is indicated in the figure.

As already discussed, our goal was to develop a robot that could learn how to cover as much much distance as possible while avoid obstacles on its way. In order to evolve Braitenberg like vehicles, we needed to incorporate features into our fitness function which solely relies on a set of variables that can be measured within the interaction between the robot and the environment. Hence our fitness criterion consists of two fitness classes: \emph{aggregate fitness function} and \emph{behavioral fitness function} \cite{divband2015effect}.

\emph{Aggregate fitness function} have the lowest degree of knowledge (traveled distance), and evaluate only what is achieved. In our case it relies on traveled distance. The procedure of how the robot accomplishes the task is irrelevant. The aggregate fitness function is defined by the distance that the robot traveled during the evaluation:

\[ aff = \sum_{t=1}^{t_{max}} \sqrt{(x_{previous} - x_{current})^2 + (y_{previous} - y_{current})^2} \]

On the other hand \emph{behavioral fitness function} measures how the task is solved, hence it requires priori knowledge about options how the task can be solved. This way BFF also predetermine potential solutions and possibly exclude counterintuitive options \cite{divband2015effect}. The \emph{bff} is a function of three variables, as follows:


\[ f_{t} = V_{t} (1-\Delta v) (1 - P_{t}) \]

\[ bff = \sum_{t=1}^{t_{max}} f_{t} \]


where \(V_{t} = \frac{V_{l} + V_{}r}{2} \) is a average speed of the both wheels at a particular timestamp \emph{t}, \(|v_{l} - v_{r}|\) is the algebraic difference between the speed values of the wheels and \((1 - P{t})\) is the activation value of the proximity sensor with the highest activity. The \emph{behavioral fitness function} has 3 components. The first component is the average of the two wheel speeds. The faster the robot moves the better it accomplishes the task. Second, the penalty term between the two speeds is minimized by \((1-\sqrt{\Delta v})\). The last component is pleasure \(P{t}\) and rewards to stay away from obstacles. If the robot is getting closer to the obstacle, then it is interpreted as a penalty.

Following our fitness function strategy we defined \emph{tailored fitness function} which combines the elements of behavioral and aggregate fitness functions. Thus the fitness function is defined as dot product of \emph{bff} and \emph{aff}:

\[ fitness = aff * bff \]

\section{Experiments}

The goal of all experiments was to explicitly evolve agents that could navigate within a specific environment without hitting obstacles and compare the performance of evolution with neuroevolution . The fitness function applied was specifically designed to enforce this type of behahavior.

\subsection{Classical Evolutionary Algorithm}

\subsubsection{The Experiment}

The aforementioned evolutionary algorithm employed in the experiments consisted in applying a simplest evolutionary algorithm from the python DEAP library\city{fortin2012deap} which is presented in Chapter 7 of \emph{Evolutionary Computation I}\cite{back2000evolutionary}. The individual genes were coded as floating point numbers in range between 0 and 3 on the chromosome. The chromosomes were mapped to phenotypes as wheel speed contributors. Each chromosome in the population had the same constant length (size of 32) corresponding to number of sensors and genes associated with that sensor. Each sensor connection was associated with four genes, representing active or in-active states and the left and right wheels of the agent. The wheel speed units are summed from each sensors input contribution depending its current state (active or in-active) and are used to directly set the velocity of the wheels.

\begin{figure}[H]
  \includegraphics[width=0.66\linewidth]{img/encoding.JPEG}
  \caption{Genotype phenotype mapping.}
  \label{fig:encoding}
\end{figure}

Each individual in the population was encoded as summarized in figure \ref{fig:encoding}. The robot started from same position every simulation and could move freely for a limited of time, each simulation lasted 40 seconds. All individuals in the population had been bound to 3 genetic operators, \emph{selection, mutation, crossover}. Selection procedure is applied to entirely replace the parental population. \emph{Tournament} strategy was applied by selecting the 3 best individuals for breeding. All offspring population, were a random combination of pair of parents and two-point crossover was performed with a given probability. Each individual after the offspring was created were mutated with a given probability.

\subsubsection{Results}

he first experimental configuration can be seen in table \ref{fig:experiment_1}. During the the first generations, the robot keeps colliding mostly with objects in front of him. After few generations, the robot start to make left turns, but still got stuck. However, after a short time the robot learned how to avoid the left closest obstacles and caused the robot to turn into small circles. During the next generations, this circling pattern is preserved, but the radius kept larger, it improved its objective avoidance behavior. Also a surprising  subjective observation was that the robot moved much slower than in the previous generations. This issue brought uncertainty, it was hard to define whether the evolution got stuck in a local optimal solution, which could be constantly repeated or rather the resulting behavior can be interpreted as a wall following, that emerged from the evolution process even thought its not part of the fitness function. To tackle this issue we tweaked some of the parameters of the evolutionary process.

\begin{table}[H]
\begin{tabular}{ll}
\hline
\textbf{}                      & \textbf{} \\ \hline
\textbf{Population Size}       & 80        \\
\textbf{Number of Generations} & 40        \\
\textbf{Simulation time}       & 40 sec    \\
\textbf{Crossover}             & 0.4       \\
\textbf{Mutation}              & 0.3       \\
\textbf{Tournament Selection}  & 3        
\end{tabular}
\caption{Experiment 1}
\label{fig:experiment_1}
\end{table}

\subsection{Neuroevolution}

NeuroEvolution of Augmenting Topologies \cite{stanley2002evolving} is a genetic algorithm for evolving both weights and topology of artificial neural networks. NEAT starts with minimal ANN structure and grows incrementally, which ensures low dimensionality of the connection weights and therefore minimizes the search space.

\subsubsection{The Experiment}

The following experiments were similar to the previous one. However in this case the genome is represented as a neural network. The genome contains a list of \emph{connection genes} and list of \emph{nodes genes} which appears in the phenotype. Node genes represents inputs, hidden nodes, and outputs that can be connected. Whether a in-node and out-node is connected is expressed in the \emph{connection gene}. The initial neural network architecture consisted from 16 input nodes (each represented the proximity sensors placed around the robot), fully connected to the two output nodes (directly connected to motor wheels) with \emph{sigmoid} activation function. The algorithm starts with fixed topology and by applying biological operators over generations it grows. 

\begin{figure}[H]
  \includegraphics[width=0.66\linewidth]{img/neat_encoding.JPG}
  \caption{Genotype phenotype mapping in NEAT.}
  \label{fig:encoding}
\end{figure}

\subsubsection{Results}

Donec euismod iaculis pretium. Donec non massa elit. Phasellus sagittis magna et maximus dictum. Duis quis ullamcorper orci. Mauris interdum, elit eu tincidunt tempor, lectus mi venenatis purus, quis posuere tellus ex in magna. Phasellus tincidunt nibh eu tortor semper, et varius justo vulputate. Nullam dictum congue lacinia. Maecenas sagittis nulla quis leo fringilla viverra. Proin eget egestas nisl. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum a interdum tellus, a hendrerit ligula. Duis ut risus ut lacus maximus euismod. Integer quis justo sit amet sapien accumsan rutrum nec nec dolor. Aliquam laoreet scelerisque ante, quis hendrerit ipsum viverra tempor.

\section{Conclusion}

Donec euismod iaculis pretium. Donec non massa elit. Phasellus sagittis magna et maximus dictum. Duis quis ullamcorper orci. Mauris interdum, elit eu tincidunt tempor, lectus mi venenatis purus, quis posuere tellus ex in magna. Phasellus tincidunt nibh eu tortor semper, et varius justo vulputate. Nullam dictum congue lacinia. Maecenas sagittis nulla quis leo fringilla viverra. Proin eget egestas nisl. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum a interdum tellus, a hendrerit ligula. Duis ut risus ut lacus maximus euismod. Integer quis justo sit amet sapien accumsan rutrum nec nec dolor. Aliquam laoreet scelerisque ante, quis hendrerit ipsum viverra tempor.

\section{Summary}

Donec euismod iaculis pretium. Donec non massa elit. Phasellus sagittis magna et maximus dictum. Duis quis ullamcorper orci. Mauris interdum, elit eu tincidunt tempor, lectus mi venenatis purus, quis posuere tellus ex in magna. Phasellus tincidunt nibh eu tortor semper, et varius justo vulputate. Nullam dictum congue lacinia. Maecenas sagittis nulla quis leo fringilla viverra. Proin eget egestas nisl. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum a interdum tellus, a hendrerit ligula. Duis ut risus ut lacus maximus euismod. Integer quis justo sit amet sapien accumsan rutrum nec nec dolor. Aliquam laoreet scelerisque ante, quis hendrerit ipsum viverra tempor.

\medskip

\newpage
\bibliographystyle{unsrt}
\bibliography{bibitems}

\end{document}
